\section{Related Works}
\label{sec:related_works}
The \emph{co-movement patterns} in literature consist 
of five members, namely \emph{group}~\cite{wang2006grouppattern}, \emph{flock}~\cite{gudmundsson2004flock},
\emph{convoy}~\cite{jeung2008convoy}, \emph{swarm}~\cite{li2010swarm} and \emph{platoon}~\cite{li2015platoon}.
We have demonstrated the semantics of these patterns in Table~\ref{tbl:existing_co_patterns} and Figure~\ref{fig:related_work}.
In this section, we focus on comparing the techniques used in these works. 
%Another related area to our work is \emph{Trajectory Clustering}, we summarize several of the representative techniques in the later part of the section. 
For more trajectory patterns other than \emph{co-movement patterns}, 
interested readers may move to~\cite{zheng2015survey} for a comprehensive survey.

%The \emph{Co-movement Pattern} belongs to the area of 
%\emph{Spatio-Temporal Pattern} in trajectory mining where many research works are spawned.
%In this section, we only focus on two closest area of literature namely \emph{Co-Movement Pattern Mining}
%and \emph{Trajectory Clustering}. As far as we know, there is little research
%works on providing parallel solutions to \emph{Co-Movement Pattern} mining. 

\subsection{Flock and Convoy}
The difference between \emph{flock} and \emph{convoy} lies 
in the object clustering methods. In \emph{flock}
objects are clustered based on their distance. Specifically, the
objects in the same cluster needs to have a pair-wised distance less than \emph{min\_dist}. 
This essentially requires the objects to be within a disk-region of delimiter less than \emph{min\_dist}.
In contrast, \emph{convoy} cluster the objects using density-based clustering~\cite{birant2007st}.
Technically, \emph{flock} utilizes a $m^{th}$-order Voronoi diagram~\cite{laube2005finding} to detect whether
a subset of object with size greater than $m$ stays in a disk-region. \emph{Convoy} employs
a trajectory simplification~\cite{douglas1973trajectorysimplification} technique to boost pairwise distance computations in
the density-based clustering.
After clustering, both \emph{flock} and \emph{convoy} use a line-sweep 
method to scan each snapshots. During the scan, the object
group appears in consecutive timestamps is detected. Meanwhile, the object groups that do not
match the consecutive constraint are pruned. 
However, such a method faces high complexity issues when supporting other patterns.
For instance, in \emph{swarm}, the candidate set during the line-sweep grows
exponentially, and many candidates can only be pruned after the entire snapshots are scanned.

\subsection{Group, Swarm and Platoon}
Different from \emph{flock} and \emph{convoy}, all the \emph{group},\emph{swarm} and \emph{platoon}
patterns have more constraints on the pattern duration. Therefore, their techniques of mining are of
the same skeleton. The main idea of mining is to grow object set from an empty set
in a depth-first manner. During the growth, various pruning techniques are provided to prune 
unnecessary branches. \emph{Group} pattern uses the Apriori property among patterns to facilitate the pruning.
\emph{Swarm} adapts two more pruning rules called backward pruning and forward pruning. \emph{Platoon}
further adapts a prefix table structure to guide the depth-first search. As shown by Li et.al.~\cite{li2015platoon},
\emph{platoon} outperforms other two methods in efficiency. 
However, the three patterns are not able to directly discover the general co-movement pattern.
Furthermore, their pruning rules heavily rely on the depth-first search nature, which lost its efficiency
in the parallel scenario.

%THESE WORKS ARE MOST RELATED TO OUR PROBLEMS, SO I REMOVED OTHER RELATED WORKS FOR NOW. 

\subsection{MaReduce Framework}
MapReduce (MR) was formally proposed by Dean et.al.~\cite{dean2008mapreduce}
and has subsequently implemented by many open source systems. Those systems
provide handy APIs with fault tolerances and are popularly
used as large-scale data processing platforms. 
In simple words, there are two conceptual types of computing nodes in MR,
namely the \emph{mapper}s and the \emph{reducer}s. The execution of a MR 
algorithm consists of three major steps: First, input data
are partitioned and read by a \emph{map} function on each mapper. Then, mappers
emit key-value pairs which are \emph{shuffle}d over the network to reducers. Lastly,
reducers process the received data using a \emph{reduce} function. 

%Despite the simpleness of the paradigm, there are two concerns raised in designing MR algorithms
%First, since reducers are required to be independent, partitioning  
%data to fit the independence could be challenging. Second, since the \emph{shuffle}
%step requires network access, the data been shuffled should be minimized. 
%We take these concerns in consideration when designing our solutions for mining GCMP.
%
%Our GCMP mining process consists of two MR jobs as illustrated in Figure~\ref{fig:overview}.
%The first MR job is to cluster objects at each snapshot (i.e.,
% $\forall t, o,$ compute $C_t(o)$). As shown in Figures~\ref{fig:overview}(a)-(b),
%in map phase, trajectories are firstly reorganized by timestamps and object locations
%at the same timestamps form a snapshot. In reduce phase, clustering of objects at each
%snapshot is processed independently. The second MR job is to mine GCMPs from 
%clusters in each snapshot. We design and compare two MR algorithms (i.e., TRM and SPM)for 
%GCMP mining. Both the two algorithms would partition snapshots in map phase
%(as in Figure~\ref{fig:overview}(c))
%and mine GCMPs from each partition in reduce phase(as in Figure~\ref{fig:overview}(d)).

% corresponds to Figures~\ref{fig:overview}(a)-(b). The objective
%of the first job is to cluster trajectories based on snapshots (i.e.,).
%As illustrated in (a), input trajectories are read in by mappers 
%and are sprinkled into $\langle t,o \rangle$ pairs. In (b), objects with the same timestamp
%form a snapshot. Then, a user defined clustering method is applied on the objects
%in each snapshot in reducers. Between step (a) and (b), a shuffle is necessary. 
%The second
%MapReduce job corresponds to Figures~\ref{fig:overview} (c)-(d). The objective 
%of the second job is to mine the GCMP from the snapshots computed in the first job. We design
%two approaches (to be described shortly)for mining GCMP in parallel. In overview, as shown in (c), snapshots
%are first fed to mappers and different partition strategies may be selected to create
%partitions among snapshots. In (d), the partitions are then send to reducers to mine GCMP.
%The final computed results are then outputted to the end users. 

%Although we need two MR jobs to complete the GCMP mining task, 
%it is easy to pipeline the two jobs to exploit data locality.
%Specifically, the reducer output at step (b) can be directly reused 
%as the input to the mappers at step (c). Therefore we do not need to 
%transfer data between the two jobs. Modern MR platforms, especially Spark, have
%already supported such a kind of pipeline.


%\subsection{Platoon Pattern}
%Li et. al.~\cite{li2015platoon} design a prefix table based pruning rule for fast compute Platoon Pattern.

%\subsection{Trajectory Clustering}
%Another related field is trajectory clustering~\cite{he2011mrdbscan,lee2007partitionandgroup,
%li2004clusteringmovingobjects}. Lee et al. proposed a partition and group algorithm in~\cite{lee2007partitionandgroup}
%to discover trajectories segments of similar geometric layout.
%Their clustering method does not consider the temporal constraint so the patterns discovered
%are not \emph{Co-Movement} patterns.
%
%Li et al. proposed a \emph{micro-clustering} technique~\cite{li2004clusteringmovingobjects} to cluster moving objects based on their moving directions. However, its distance measured is defined upon the entire trajectory and cannot be applied in our problem to mine local patterns.
%
%In ~\cite{he2011mrdbscan}, He et al. deployed an implementation of DBSCAN on MapReduce. They decouple the dependency of original DBSCAN algorithm into a four-stage parallel process.  However their method only focuses on DBSCAN for one snapshot, where exploiting the relationship between multiple DBSCANs remains unexplored. I DON'T UNDERSTAND WHAT YOU MEAN. ONE DATASET? MULTIPLE DBSCANS?
%
%Trajectory pattern mining can be roughly classified into four categories, 
%namely \emph{Co-Movement Pattern Mining}, \emph{Frequent Sequence Mining},
%\emph{Trajectory Clustering} and \emph{Periodic Pattern Mining}. The most
%relevant literature to our work is \emph{Co-Movement Pattern Mining}. In this
%section, we focus on summarizing existing works on \emph{Co-Movement Pattern Mining}. 
%Interested readers may refer to~\cite{} for a comprehensive survey on 
%other types of trajectory mining techniques.


%The relevant literature can be classified into three groups, namely \emph{Co-Movement Patterns},
%\emph{Spatio Patterns} and \emph{Parallel Trajectory Processing Platforms}
%
%In this section, we present a comprehensive literature review on the related works. 

%\subsection{Co-movement Pattern}
%
%FOR THE CO-MOVEMENT PATTERN, YOU NEED TO EMPHASIZE TWO THINGS: 1) THE DIFFERENCE BETWEEN PATTERNS. NEED TO CLARIFY THE PARAMETERS IN EACH MODEL. 2) CLEARLY STATE THE MINING TECHNIQUES. 
%\subsection{Co-movement Pattern}
%The work most related to ours is those on \emph{co-movement} patterns. We summarize the typical patterns as follows:
%\subsubsection{group}
%Wang et al. defined \emph{group pattern}~\cite{wang2006grouppattern}, which aims to find the set of objects travelling together at certain time intervals. In \emph{group pattern}, groups at each snapshot is identified by a disc-based clustering method, where each cluster forms a circle within a radius. It is argued in later works~\cite{jeung2008convoy,li2010swarm} that such disc-based clustering is not effective as \emph{density}-based clustering where the later one may find clusters of arbitrary shapes.
%
%\subsubsection{flock}
%Gudmunsson et al. proposed \emph{flock} pattern in 
%\cite{gudmundsson2004flock,gudmundsson2006flock} and Vieria et al. followed up with an online version in~\cite{
%vieira2009onlineflock}. A \emph{flock} pattern tries to find the set of objects that stay in a circular ranged cluster for a minimum duration. Such a pattern is useful in detecting the moving companions. However, similar as \emph{group pattern}, it uses disc-based clustering, which suffers the same deficiency in discovering arbitrary shaped clusters. \emph{Flock} pattern has many derivatives. In \cite{benkert2006meet}, Benkert et al. studied \emph{meet} pattern, which require the clusters in the pattern to be geographically stationary. Giannotti et al. studied \emph{leadership} pattern~\cite{andersson2007leadership} which requires a leader object exists for each flock cluster.
%
%%In \cite{benkert2006meet}, Benkert et al. studied \emph{meet} pattern. A \emph{meet} pattern aims to find a set of objects stay
%%stationary with in a circular range for some durations. This pattern does not consider the temporal movement of objects. Giannotti et al. studied \emph{leadership} pattern~\cite{andersson2007leadership} which requires a set of objects stay relatively within a circular range at each snapshots for some durations and there is at least one object is heading (leader). It is shown in~\cite{giannotti2007survey} that both \emph{Meet} and \emph{leadership} patterns are special cases of the \emph{flock} pattern~\cite{gudmundsson2004flock}.
%
%
%
%\subsubsection{convoy}
%Jeung et al. proposed \emph{convoy} pattern that extends \emph{flock} pattern by replacing the disc-based clustering with \emph{density}-based clustering. Such an relaxation brings a high complexity of repeatedly running DBSCAN~\cite{birant2007st} at every snapshot. To reduced the complexity, Jeung et al. designed a filter-refine approach which first uses simplification technique~\cite{douglas1973linesimplification} to filter far away objects, and then uses coherent moving method~\cite{kalnis2005movingclusters} to find the exact convoy patterns. Along with \emph{convoy} pattern, Aung et al. proposed \emph{dynamic convoy} and \emph{evolving convoy} patterns. In \emph{dynamic convoy}, the cluster members are allowed to be absent briefly during the convoy lifetime, while \emph{evolving convoy} allows the convoy to grow or shrink in cardinality during the life time. Tang et al. also addresses the online extension in~\cite{tang2012onlineconvoy}.
%\subsubsection{swarm}
%The major argument on \emph{convoy} pattern is that \emph{convoy} requires the consecutiveness in the lifetime, which may lose many interesting patterns. To remedy, Li et al. proposed the \emph{swarm} pattern~\cite{li2010swarm} which completely relaxes the consecutiveness in \emph{convoy}. In \emph{swarm}, objects can collectively leave the cluster for a long time and then join back in later time. The only requirement in \emph{swarm} is that each member in the cluster needs to accumulate to a certain duration. In~\cite{li2010swarm}, the authors proposed a depth-first search based pruning algorithm to efficiently discover \emph{swarm} patterns.
%\subsubsection{platoon}
%Recently Li et al. argued that \emph{swarm} is to loose in the temporal consecutiveness and proposed \emph{platoon} pattern in~\cite{li2015platoon}. In \emph{platoon} pattern, the clusters should lasts for at least a certain during before dismiss. Meanwhile, \emph{platoon} allow the clusters to form again at future times. Li et al. demonstrated the such extension is more general and can support swarm and convoy patterns by setting appropriate parameters. Li et al. also provide a similar depth-first search approach as in~\cite{li2010swarm}. In addition, they adapted a prefix pruning method to further improve efficiency. It is notable that in both \cite{li2010swarm} and \cite{li2015platoon}, authors consider the input to be the clusters at each snapshot, which ignores the clustering time.
%
%\subsection{Other Related Trajectory Patterns}
%Besides co-movement patterns, there are a number of other types of trajectory patterns proposed in previous works.
%%General Trajectory pattern mining a hot field in trajectory analysis. Previous works
%%define various patterns~\cite{
%%kalnis2005movingclusters,
%%li2010periodicpattern,zheng2013gathering,jinno2012paralleltpattern,li2013onlinegroup} over trajectory data, which have proven their usefulness under different applications~\cite{giannotti2007survey}. 
%
%Kalnis et al. proposed \emph{moving clusters} pattern~\cite{kalnis2005movingclusters}. In such a pattern, objects form clusters at each snapshot. For consecutive snapshots, the clusters in the pattern should have a Jaccard index greater than a threshold. Under such a scheme, the difference between cluster members in snapshots accumulates, therefore the clusters at later snapshot may be very different from those in previous snapshots. The online extension is studied by Li et al.~\cite{li2013onlinegroup}. IT'S DIFFERENCE WITH CO-MOVEMENT PATTERN IS NOT CLEAR. WHAT IS JACCARD INDEX?
%
% In~\cite{li2010periodicpattern}, Li et al. studied the \emph{periodic} pattern, which mines objects with periodic behaviors. 
%It is commented in~\cite{giannotti2007survey} that \emph{periodic} pattern is unsuitable for discovering movements, since it is unreasonable to expect an object to repeat its behavior exactly during each time period considered. AGAIN, WHAT'S YOUR POINT? YOU MEAN SUCH A WORK IS MEANINGLESS? THEN, WHY BOTHER TO MENTION IT HERE?
%
%Zhang et al. proposed the \emph{gathering} pattern in \cite{zheng2013gathering}. It is similar to \emph{flock} pattern~\cite{gudmundsson2004flock} but with the relaxation on the members of clusters. Instead of fixing the members in clusters as in~\cite{gudmundsson2004flock}, \emph{gathering} pattern allows members in clusters leave and join during the pattern duration. Since it relaxes the member constraints, it is unable to model co-movement patterns. HOW TO DEFINE CO-MOVEMENT PATTERN? IS THERE A PREVIOUS ``FORMAL'' DEFINITION? OR IS DEFINED BY YOU? THIS ONE LOOKS LIKE OBJECTS CO-MOVE. WHY IT IS NOT A CO-MOVEMENT PATTERN?
%
%
%%\subsection{Pattern Mining Frameworks}
%Jinno et al. recently studied the problem of processing \emph{T}- pattern~\cite{giannotti2007survey} in parallel platform \cite{jinno2012paralleltpattern}. A \emph{T}-pattern discovers a set of objects visiting the same the place in a close time interval. Such a pattern differs from moving object pattern in that \emph{T}-pattern does not consider the movement of objects. Jinno et al. in~\cite{jinno2012paralleltpattern} designed a MapReduce based algorithm for efficiently support \emph{T}-pattern discovery. However, as the nature of differences between the patterns, their work cannot directly applied on the co-moving object pattern discovery. Li et al. recently proposed a framework of processing online \emph{evolving group} pattern~\cite{li2013onlinegroup}. The \emph{evolving group} is similar to \emph{moving cluster} pattern with focus on the member updates in clusters, which is different with \emph{co-movement} pattern. Moreover the framework is developed for centralized system, thus is different with our work.
%
%\subsection{Trajectory Clustering}
%Another related field is trajectory clustering~\cite{he2011mrdbscan,lee2007partitionandgroup,
%li2004clusteringmovingobjects}. Lee et al. proposed a partition and group algorithm in~\cite{lee2007partitionandgroup} TO SOLVE WHAT PROBLEM?. Their clustering method does not consider the temporal constraint and groups trajectories from different time points together. WHY EMPHAISIS THIS? OUR CLUSTERING IS ALSO CONDUCTED IN EACH SNAPSHOT. 
%
%Li et al. proposed a \emph{micro-clustering} technique~\cite{li2004clusteringmovingobjects} to cluster moving objects based on their moving directions. However, its distance measured is defined upon the entire trajectory and cannot be applied in our problem to mine local patterns.
%
%In ~\cite{he2011mrdbscan}, He et al. deployed an implementation of DBSCAN on MapReduce. They decouple the dependency of original DBSCAN algorithm into a four-stage parallel process.  However their method only focuses on DBSCAN for one datasets, where exploiting the relationship between multiple DBSCANs remains unexplored. I DON'T UNDERSTAND WHAT YOU MEAN. ONE DATASET? MULTIPLE DBSCANS?